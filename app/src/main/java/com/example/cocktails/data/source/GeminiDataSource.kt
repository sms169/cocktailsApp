package com.example.cocktails.data.source

import com.example.cocktails.model.Cocktail
import com.google.ai.client.generativeai.GenerativeModel
import com.google.ai.client.generativeai.type.content
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import org.json.JSONArray
import org.json.JSONObject

class GeminiDataSource : CocktailDataSource {

    // TODO: Replace with your actual API Key
    private val apiKey = "AIzaSyB0q4KCOdfeD1icNSCw1MR16--LWgw1PlM" 
    
    private val generativeModel = GenerativeModel(
        modelName = "gemini-pro",
        apiKey = apiKey
    )

    override suspend fun searchCocktails(userIngredients: List<String>): List<Cocktail> = withContext(Dispatchers.IO) {
        if (userIngredients.isEmpty()) return@withContext emptyList()

        val prompt = """
            Suggest 5 cocktails that can be made with some or all of these ingredients: ${userIngredients.joinToString(", ")}.
            Return the result ONLY as a JSON array of objects. 
            Each object must have these fields:
            - id: a unique string id (e.g. "gemini_1")
            - name: string
            - ingredients: array of strings
            - calories: integer (estimate)
            - description: string (short instructions)
            - history: string (brief history or fun fact)
            - rating: double (4.0 to 5.0)
            - popularity: integer (0 to 100)
            
            Do not include markdown formatting like ```json ... ```. Just the raw JSON.
        """.trimIndent()

        try {
            val response = generativeModel.generateContent(prompt)
            val jsonString = response.text?.replace("```json", "")?.replace("```", "")?.trim() ?: "[]"
            parseCocktailsJson(jsonString)
        } catch (e: Exception) {
            e.printStackTrace()
            emptyList()
        }
    }

    override suspend fun getCocktailById(id: String): Cocktail? {
        // Gemini generates cocktails on the fly, so we can't easily "fetch" one by ID later 
        // unless we cache them. For simplicity, we'll just return null or handle it in the UI.
        // A better approach would be to cache the search results in the Repository.
        return null 
    }

    private fun parseCocktailsJson(jsonString: String): List<Cocktail> {
        val cocktails = mutableListOf<Cocktail>()
        try {
            val jsonArray = JSONArray(jsonString)
            for (i in 0 until jsonArray.length()) {
                val obj = jsonArray.getJSONObject(i)
                val ingredientsArray = obj.getJSONArray("ingredients")
                val ingredientsList = mutableListOf<String>()
                for (j in 0 until ingredientsArray.length()) {
                    ingredientsList.add(ingredientsArray.getString(j))
                }

                cocktails.add(
                    Cocktail(
                        id = obj.optString("id", "gemini_$i"),
                        name = obj.getString("name"),
                        ingredients = ingredientsList,
                        calories = obj.optInt("calories", 200),
                        description = obj.getString("description"),
                        history = obj.optString("history", "Generated by Gemini"),
                        imageUrl = "", // Gemini doesn't provide images easily without Imagen
                        youtubeUrl = "https://www.youtube.com/results?search_query=${obj.getString("name").replace(" ", "+")}+cocktail+recipe",
                        rating = obj.optDouble("rating", 4.5),
                        popularity = obj.optInt("popularity", 80)
                    )
                )
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
        return cocktails
    }
}
